# 预备知识
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731827551827-ca1a38b1-6674-4aea-8b44-e1cb14db2c2b.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731827820414-647767bc-be89-4cfc-8952-5f13e1e2ed9a.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731827849410-dd795397-882b-4ec1-b18f-270daf337d58.png)

除了3不可以，其他两个都可以

# 导引问题：从递归说起
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731828059930-2a2e0103-57be-41bf-8e3f-bfe5c7564f3f.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731828107977-ba50f64f-2507-4e7e-a7ca-cb1bfbde01f9.png)

# 字符全排列
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731828247047-895eb939-40db-4d18-9d87-e0ce7ac4bba1.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731828406922-0c2ca6d5-63b1-4228-b745-8f53ad8efb81.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int num[10], vis[10];
void dfs(int step);

int main()
{
    while (scanf("%d", &n) == 1)
    {
        memset(vis, 0, sizeof(vis));
        dfs(1);
    }
    return 0;
}

void dfs(int step)
{
    if (step == n + 1)
    {
        for (int i = 1; i <= n; i++)
        {
            printf("%d ", num[i]);
        }
        printf("\n");
        return;
    }
    for (int i = 1; i <= n; i++)
    {
        if (vis[i] == 0)
        {
            num[step] = i;
            vis[i] = 1;
            dfs(step + 1);
            vis[i] = 0;
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731829397840-c54641eb-031b-4518-812f-7e83e647edd5.png)

+ 当`step`等于`n + 1`时，表示已经找到了一组解，将`num`数组中的值打印出来，并返回。
+ 对于每个未被访问的节点`i`（`vis[i] == 0`）：
    - 将`num[step]`设置为`i`，表示选择节点`i`。
    - 将`vis[i]`设置为 1，表示节点`i`已经被访问。
    - 递归调用`dfs(step + 1)`继续搜索下一层。
    - 回溯时，将`vis[i]`设置为 0，表示取消对节点`i`的访问，以便其他路径可以选择这个节点。
+ **回溯的触发条件**
    - 当`dfs`函数中的`step`等于`n + 1`时，表示已经找到了一组解，此时函数会返回到上一层。
    - 在`for`循环中，当尝试完所有可能的节点后，函数也会返回到上一层。
+ **回溯的实现**
    - 在`dfs`函数中，当递归调用`dfs(step + 1)`返回后，会执行`vis[i] = 0;`这一行代码。这就是回溯的关键步骤，将`vis[i]`设置为 0，表示取消对节点`i`的访问，允许其他路径选择这个节点。
    - 这样，在`for`循环中，程序会尝试下一个未被访问的节点，继续搜索。

# 深度优先搜索的基本模型
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731830343998-3076c127-9559-4aea-8964-f4f2b45ae752.png)

# 开门/关门问题
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731831897848-47b1fa91-250e-4abe-943d-38b2c3d81cbf.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731831989051-5542d2ad-368c-43a7-b1fa-73182a1936ce.png)

## 奇偶性剪枝
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731832597153-c88b5a40-d48a-4a90-99e1-d59bed78d04e.png)

```cpp
#include <bits/stdc++.h>
using namespace std;

// 定义一个9x9的字符数组Map，用于存储迷宫地图
char Map[9][9]; 
// 定义变量n, m, t, di, dj
int n, m, t, di, dj;
// 定义一个布尔变量escape，用于判断是否找到出口
bool escape;
// 定义一个二维数组dir，用于表示四个方向的偏移量，方向
int dir[4][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};
// 定义函数dfs，用于深度优先搜索
void dfs(int si, int sj, int cnt);

int main()
{
    // 定义变量i, j, si, sj
    int i, j, si, sj;
    // 循环读取输入，直到没有输入为止
    while (cin >> n >> m >> t)
    {
        // 如果n, m, t都为0，则跳出循环
        if (n == 0 && m == 0 && t == 0)
            break;
        // 初始化墙壁数量为0
        int wall = 0;
        // 读取迷宫地图
        for (i = 1; i <= n; i++)
        {
            for (j = 1; j <= m; j++)
            {
                cin >> Map[i][j];
            }
        }
        // 初始化escape为false
        escape = false;
        // 遍历迷宫地图，找到起点S
        for (i = 1; i <= n; i++)
        {
            for (j = 1; j <= m; j++)
            {
                if (Map[i][j] == 'S')
                {
                    si = i;
                    sj = j;
                }
                // 如果是墙壁，墙壁数量加1
                else if (Map[i][j] == 'D')
                {
                    di = i;
                    dj = j;
                }
                else if (Map[i][j] == 'X')
                {
                    wall++;
                }
            }
        }
        // 如果可走的步数小于墙壁数量，则无法到达出口
        if (n * m - wall - 1 < t)
        {
            cout << "NO" << endl;
            continue;
        }
        // 初始化escape为0，将起点标记为已访问
        escape = 0;
        Map[si][sj] = 'X';
        // 从起点开始进行深度优先搜索
        dfs(si, sj, 0);
        // 根据escape的值输出结果
        if (escape)
            cout << "YES" << endl;
        else
            cout << "NO" << endl;
    }
    return 0;
}

// 深度优先搜索函数
void dfs(int si, int sj, int cnt)
{
    // 如果当前位置是出口，标记escape为true并返回
    if (Map[si][sj] == 'D')
    {
        escape = true;
        return;
    }
    // 遍历四个方向
    for (int k = 0; k < 4; k++)
    {
        int newi = si + dir[k][0];
        int newj = sj + dir[k][1];
        // 如果新位置在迷宫范围内且不是墙壁且未被访问
        if (newi >= 1 && newi <= n && newj >= 1 && newj <= m && Map[newi][newj]!= 'X')
        {
            // 将新位置标记为已访问
            Map[newi][newj] = 'X';
            // 继续进行深度优先搜索
            dfs(newi, newj, cnt + 1);
            // 如果已经找到出口，直接返回
            if (escape)
                return;
            // 将新位置标记为未访问，回溯
            Map[newi][newj] = '.';
        }
    }
}
```

1. **输入处理**
    - 从标准输入读取迷宫的行数`n`、列数`m`和可用步数`t`。
    - 读取迷宫地图，用`S`表示起点，`D`表示出口，`X`表示墙壁，`.`表示可走的路。
    - 统计墙壁数量`wall`，并检查是否有足够的步数到达出口（`n * m - wall - 1 < t`）。
2. **深度优先搜索（DFS）**
    - 从起点`S`开始进行深度优先搜索。
    - 使用`dfs`函数递归地探索迷宫。
    - 每次探索一个新位置时，将其标记为已访问（`X`），并继续探索其相邻位置。
    - 如果找到出口，设置`escape`为`true`并返回。
    - 如果步数超过`t`，则停止搜索。
    - 搜索完成后，根据`escape`的值输出结果（`YES`或`NO`）。
3. **方向数组**`**dir**`
    - 定义了四个方向的偏移量：上、下、左、右。
    - 在`dfs`函数中用于探索相邻位置。
4. **主函数**`**main**`
    - 循环读取输入，直到没有输入为止。
    - 对每个迷宫地图进行处理和搜索。

这段代码实现了一个简单的迷宫求解器，使用深度优先搜索算法来判断是否能从起点到达出口。

```cpp
void dfs(int si, int sj, int cnt)
{
    int i, temp;
    if (si > n || sj > m || si <= 0 || sj <= 0) return;
    if (cnt == t && si == di && sj == dj) escape = 1;
    if (escape) return;
    temp = (t - cnt) - abs(si - di) - abs(sj - dj);
    if (temp < 0 || temp % 2 == 1) return;
    for (i = 0; i < 4; i++)
    {
        if (Map[si + dir[i][0]][sj + dir[i][1]]!= 'X')
        {
            Map[si + dir[i][0]][sj + dir[i][1]] = 'X';
            dfs(si + dir[i][0], sj + dir[i][1], cnt + 1);
            Map[si + dir[i][0]][sj + dir[i][1]] = '.';
        }
    }
    return;
}
```

这段代码是一个深度优先搜索（DFS）函数，用于在迷宫中寻找路径。以下是对代码的详细解释：

1. **函数定义**
    - `void dfs(int si, int sj, int cnt)`: 这是一个递归函数，用于深度优先搜索。
        * `si` 和 `sj` 是当前搜索的坐标。
        * `cnt` 是已经走过的步数。
2. **变量声明**
    - `int i, temp;`: 声明了两个整数变量，用于循环和临时计算。
3. **边界条件检查**
    - `if (si > n || sj > m || si <= 0 || sj <= 0) return;`: 如果当前坐标超出了迷宫的边界，函数返回，不继续搜索。
4. **目标条件检查**
    - `if (cnt == t && si == di && sj == dj) escape = 1;`: 如果已经走过的步数等于总步数 `t`，并且当前坐标等于目标坐标 `(di, dj)`，则标记 `escape` 为 1，表示找到了出口。
    - `if (escape) return;`: 如果已经找到了出口，函数返回，不继续搜索。
5. **路径可行性检查**
    - `temp = (t - cnt) - abs(si - di) - abs(sj - dj);`: 计算剩余步数和到达目标所需步数的差值。
    - `if (temp < 0 || temp % 2 == 1) return;`: 如果剩余步数不足以到达目标，或者差值为奇数（表示无法到达目标），函数返回，不继续搜索。
6. **搜索四个方向**
    - `for (i = 0; i < 4; i++)`: 循环遍历四个方向。
        * `if (Map[si + dir[i][0]][sj + dir[i][1]]!= 'X')`: 如果下一个位置不是墙壁（'X'）。
            + `Map[si + dir[i][0]][sj + dir[i][1]] = 'X';`: 将下一个位置标记为已访问。
            + `dfs(si + dir[i][0], sj + dir[i][1], cnt + 1);`: 递归调用 `dfs` 函数，继续搜索下一个位置。
            + `Map[si + dir[i][0]][sj + dir[i][1]] = '.';`: 回溯时，将下一个位置标记为未访问。
7. **函数返回**
    - `return;`: 函数执行完毕，返回。

# 回溯
1. **回溯算法的基本原理**回溯算法是一种用于搜索问题解空间的通用算法。它通过深度优先搜索（DFS）的方式遍历所有可能的解，并在搜索过程中通过剪枝操作来避免不必要的搜索。
    - **搜索树和状态空间**
        * 大多数回溯问题可以被看作是在一棵搜索树中寻找目标节点。树中的每个节点代表一个问题的状态，而从一个节点到其子节点的边代表了从一个状态到另一个状态的转换。
        * 例如，在迷宫问题中，每一个位置可以被看作是搜索树中的一个节点，而从一个位置移动到相邻位置就是从一个节点到其子节点的转换。
    - **深度优先搜索（DFS）**
        * 回溯算法通常采用深度优先搜索策略。这意味着在搜索过程中，算法会尽可能深地探索一条路径，直到达到一个终止条件（如找到解、确定无解或到达搜索树的叶子节点）。
        * 当达到终止条件时，算法会“回溯”到上一个状态，尝试其他可能的路径。
    - **剪枝操作**
        * 剪枝是回溯算法中的关键操作，用于减少不必要的搜索。通过在搜索过程中判断当前状态是否有可能通向解，可以避免继续搜索那些不可能通向解的路径。
        * 在迷宫问题中，剪枝操作可能包括判断剩余步数是否足够到达出口、当前位置是否超出迷宫边界等。
2. **回溯算法的实现步骤**
    - **步骤一：定义问题的状态和状态转移**
        * 首先需要确定问题的状态表示方式。例如，在迷宫问题中，状态可以用当前位置的坐标表示。
        * 然后需要定义如何从一个状态转移到另一个状态。在迷宫问题中，状态转移就是从一个位置移动到相邻位置。
    - **步骤二：实现深度优先搜索（DFS）**
        * 使用递归或栈来实现深度优先搜索。在搜索过程中，不断地深入探索一条路径，直到达到终止条件。
        * 在迷宫问题中，`dfs`函数就是实现深度优先搜索的关键部分。
    - **步骤三：实现剪枝操作**
        * 在搜索过程中，根据问题的约束条件来判断当前状态是否有可能通向解。如果不可能通向解，则立即返回，不再继续搜索这条路径。
        * 在迷宫问题中，剪枝操作包括判断坐标是否超出边界、剩余步数是否足够、是否已经找到出口等。
    - **步骤四：回溯操作**
        * 当达到终止条件（如找到解、确定无解或到达搜索树的叶子节点）时，需要回溯到上一个状态，尝试其他可能的路径。
        * 在迷宫问题中，回溯操作通过将访问过的位置重新标记为未访问来实现，例如`Map[si + dir[i][0]][sj + dir[i][1]] = '.'`，这样就可以在后续的搜索中重新考虑这个位置。
3. **回溯算法的应用场景**回溯算法广泛应用于各种组合优化问题、排列问题、子集问题和图搜索问题等，例如：

这些问题都可以通过回溯算法来解决，通过系统地搜索解空间并通过剪枝和回溯操作来提高搜索效率。

    - **八皇后问题**：在8×8的棋盘上放置8个皇后，使得任意两个皇后都不在同一行、同一列或同一对角线上。
    - **数独问题**：在9×9的数独盘中填入1 - 9的数字，使得每行、每列和每个3×3的子盘中都包含1 - 9的数字且不重复。
    - **子集和问题**：给定一个整数集合和一个目标值，判断是否存在一个子集，其元素之和等于目标值。



















































































