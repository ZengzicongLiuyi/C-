# 什么是背包
背包问题是一类经典的组合优化问题，具体描述如下：

有一个容量为`C`的背包和`n`种不同的物品，每种物品有其重量`w[i]`和价值`v[i]`。目标是在不超过背包容量的前提下，选择一些物品放入背包，使得放入背包的物品总价值最大。

**一、主要类型及特点**

1. **0/1 背包问题**：
    - 每种物品只有一个，要么被放入背包，要么不被放入，不能分割。
    - 例如，在选择旅行时要携带的物品，有些物品如相机等是不可分割的，只能选择带或者不带。
2. **完全背包问题**：
    - 每种物品有无限个，可以选择放入背包的数量为 0 个、1 个、2 个……直到背包容量无法再容纳该物品为止。
    - 例如，假设有无限数量的某种小面额货币，要凑出一定金额时，可以使用任意数量的这种货币。
3. **多重背包问题**：
    - 每种物品有一定的数量限制。
    - 例如，在超市促销活动中，某些商品有购买数量的上限。

**二、解决方法（以 0/1 背包问题为例）**

通常使用动态规划来解决背包问题。

1. **定义状态**：
    - 一般用`dp[i][j]`表示前`i`个物品在背包容量为`j`时能获得的最大价值。
2. **状态转移方程**：
    - 对于第`i`个物品，如果不放入背包，则`dp[i][j]=dp[i - 1][j]`，即当前状态等于不考虑第`i`个物品时的状态。
    - 如果放入背包，则`dp[i][j]=dp[i - 1][j - w[i]] + v[i]`，即等于前`i - 1`个物品在背包容量为`j - w[i]`时的最大价值加上第`i`个物品的价值。
    - 最终的`dp[i][j]`取这两种情况中的较大值，即`dp[i][j]=max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i])`。
3. **求解过程**：
    - 通过遍历物品和背包容量，按照状态转移方程逐步填充`dp`数组，最终`dp[n][C]`就是所求的最大价值。

背包问题在实际生活中有很多应用，如资源分配、项目选择等，是算法学习中的重要内容之一。

# 背包问题的分类
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731311882858-6617da50-9039-48c7-ad2c-60e41550fee3.png)

# 01背包
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731312244117-28d62a95-2f45-47dc-8b24-479bb466069f.png)

# 骨头背包问题
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731312573669-0912a439-b84d-4330-a280-053658d97072.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731327955281-44b4d853-49d9-4ec4-8645-863766e000bb.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731337913918-d56a170b-fcd3-4a82-a98e-a881a8749752.png) 

```cpp
#include <iostream>
#include <cstring>

int main() {
    int num, n, V, i, j;
    // 读取测试用例的数量
    std::cin >> num;
    while (num--) {
        // 读取物品数量 n 和背包容量 V
        std::cin >> n >> V;
        int w[1000], c[1000];
        // 读取每个物品的重量存入 w 数组
        for (i = 0; i < n; i++) std::cin >> w[i];
        // 读取每个物品的价值存入 c 数组
        for (i = 0; i < n; i++) std::cin >> c[i];
        int dp[1001];
        // 将 dp 数组初始化为 0，dp[j] 表示容量为 j 的背包能装的最大价值
        std::memset(dp, 0, sizeof(dp));
        for (i = 0; i < n; i++) {
            // 遍历背包容量，从大到小更新 dp 数组
            for (j = V; j >= c[i]; j--) {
                // 比较不放入当前物品和放入当前物品两种情况下的价值，取较大值
                dp[j] = std::max(dp[j], dp[j - c[i]] + w[i]);
            }
        }
        // 输出背包容量为 V 时的最大价值
        std::cout << dp[V] << std::endl;
    }
    return 0;
}
```

# 完全背包
完全背包特点：一种物品可以取无数个

**问题描述**：

有一个容量为  的背包和  种物品，每种物品都有无限个可用。每种物品有重量  和价值 。求在不超过背包容量的前提下，能够装入背包的最大价值。

**与 01 背包的区别**：

在 01 背包问题中，每种物品只有一个，要么放入背包，要么不放入。而在完全背包问题中，每种物品有无限个可用。

**解决思路（动态规划）**：

1. **定义状态**：
    - 设 `dp[i][j]` 表示前 `i` 种物品放入容量为 `j` 的背包中可以获得的最大价值。
2. **状态转移方程**：
    - 如果不放入第 `i` 种物品，即 `dp[i][j] = dp[i - 1][j]`。
    - 如果放入第 `i` 种物品，可以放入  个（ 满足 ），则 `dp[i][j] = max(dp[i][j], dp[i][j - k * w[i]] + k * v[i])`。
    - 综合起来，状态转移方程为 `dp[i][j] = max(dp[i - 1][j], dp[i][j - w[i]] + v[i])`。
3. **初始化**：
    - `dp[0][0] = 0`，表示没有物品和容量为 0 时最大价值为 0。
    - 对于其他 `dp[0][j] = 0`（当 `j > 0`），因为没有物品时无法获得价值。
4. **计算顺序**：
    - 外层循环遍历物品，内层循环遍历背包容量，从小到大进行计算。

```cpp
#include <iostream>
#include <cstring>

int main() {
    int num, n, V, i, j;
    std::cin >> num;
    while (num--) {
        // 输入测试用例数量
        std::cin >> n >> V;
        int w[1000], c[1000];
        for (i = 0; i < n; i++) std::cin >> w[i];
        for (i = 0; i < n; i++) std::cin >> c[i];
        int dp[1001];
        std::memset(dp, 0, sizeof(dp));
        for (i = 0; i < n; i++) {
            // 遍历每种物品
            for (j = c[i]; j <= V; j++) {
                // 考虑当前背包容量为 j 的情况
                // dp[j] 表示当前背包容量下不放入当前物品的最大价值
                // dp[j - c[i]] + w[i] 表示放入当前物品后的最大价值
                dp[j] = std::max(dp[j], dp[j - c[i]] + w[i]);
            }
        }
        std::cout << dp[V] << std::endl;
        // 输出背包容量为 V 时的最大价值
    }
    return 0;
}
```

# 多重背包
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731341659194-eabb28da-905b-446a-bb3b-8fdbb3cd74be.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731341737143-80dbabc3-2342-4884-a295-1c2af4193c87.png)

![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731341993742-3b0100d5-3e6a-45ea-9310-c2b3053069e5.png)

# 二维费用背包
![](https://cdn.nlark.com/yuque/0/2024/png/43034535/1731342120884-43854595-6d29-4bc3-9624-61c1c22ce6e9.png)































































































